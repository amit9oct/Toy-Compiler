/*
**************************************
*  Batch Number: 9
*  Amitayush Thakur 2012B4A7819P
**************************************
*/
#include "parser.h"
#include "lexer.h"
#include "ast.h"
#include "symbolTable.h"
#include "codeGeneration.h"
#include "error.h"
#include <stdio.h>
#include <string.h>

typedef struct funvar{
	VariableNode* varNode;
	struct funvar* next;
}FunVar;

typedef struct funlist{
	Token* funTok;
	FunVar* varList;
	struct funlist* next;
}FunList;

FunList* functions = NULL;

char DataType[][30] = {
	"int",
	"real"
};


void printWithoutComments(char* filename){
	FILE* fp = open(filename);
	if(fp==NULL){
		printf("Fatal Error: File doesn't exist\n");
		exit(-1);
	}
	int forward = 0;
	int curBuffer = 0;
	int commentStarted = 0;
	char c;
	fillBuffer(fp,curBuffer);
	c = buffer.buffer[curBuffer][forward];
	while(c!='\0'){
		//printf("THis is the ");
		if(c=='%'){
			commentStarted = 1;
		}
		if(c=='\n' && commentStarted){
			commentStarted = 0;
		}
    	if(!commentStarted){
    		printf("%c",c);
    	}		
		if(forward<MAX_BUFFER_CAPACITY){
        	c = buffer.buffer[curBuffer][forward];
    	}
    	else{
        	fillBuffer(fp,!curBuffer);
    		curBuffer = !curBuffer;
        	forward=0;
        	c = buffer.buffer[curBuffer][forward];
    	}
    	forward++;
	}
	fclose(fp);
}

void printInitMessage(){
	printf("\nLevel 4: Symbol table/AST/Semantic Rules/Type Check and Code Generation module works\n");
	printf("INT is assumed to be of 4 bytes\n");
	printf("REAL is assumed to be of 8 bytes\n");
	printf("\n\n");
	printf("Press keys:\n");
	printf("\t1 - To print token list generated by lexer\n");
	printf("\t2 - To print the parse tree on stdout\n");
	printf("\t3 - To print the abstract syntax tree on stdout\n");
	printf("\t4 - To print the number of nodes and Compression\n");
	printf("\t5 - To print the symbol table\n");
	printf("\t6 - To print the semantic and syntactic errors if any\n");
	printf("\t7 - To output the asm code in the output file specified\n");
	printf("\t8 - To run the asm code\n");	
	printf("Press '0' to exit\n");			
}

void printHash2(HashTable* htPtr){
	printf("-------Printing the hash table------ size = %d %d\n",htPtr->size,htPtr->elem);
    int i;
	for(i=0;i<htPtr->size;i++){
		Entry* ent = &(htPtr->table[i]);
		while(ent!=NULL){
			if(ent->value!=NULL){
				printf("key = %d value = %s width=%d\n",
						ent->key,
						((RecordNode*)ent->value)->recTok->lexemeName,
						((RecordNode*)ent->value)->width
						);
				FieldList* head = ((RecordNode*)ent->value)->fields;
				while(head!=NULL){
					printf("\t %s %d\n",head->token->lexemeName,head->width);
					head = head->next;
				}
			}
			ent = ent->next;
		}
	}
}


void printHash3(HashTable* htPtr){
	printf("-------Printing the hash table------ size = %d %d\n",htPtr->size,htPtr->elem);
    int i;
	for(i=0;i<htPtr->size;i++){
		Entry* ent = &(htPtr->table[i]);
		while(ent!=NULL){
			if(ent->value!=NULL){
				printf("key = %d value = %s of function = %s of type = %d offset=%d isGlobal=%d width=%d\n",
											ent->key,((VariableNode*)ent->value)->varTok->lexemeName,
											((VariableNode*)ent->value)->funTok->lexemeName,
											((VariableNode*)ent->value)->type,
											((VariableNode*)ent->value)->offset,
											((VariableNode*)ent->value)->isGlobal,
											((VariableNode*)ent->value)->width
											);
			}
			ent = ent->next;
		}
	}
}


FunList* createFunList(Token* funTok, VariableNode* var){
	FunList* function = (FunList*)malloc(sizeof(FunList));
	function->funTok = funTok;
	//printf("VariableNode=%s %p\n",var->varTok->lexemeName,funTok);
	function->next = NULL;
	function->varList = (FunVar*)malloc(sizeof(FunVar));
	function->varList->varNode = var;
	function->varList->next = NULL;
	return function;
}

FunVar* createFunVar(VariableNode* var){
	FunVar* fvar = (FunVar*)malloc(sizeof(FunVar));
	fvar->varNode = var;
	fvar->next = NULL;
	return fvar;
}

char* printType(RecordNode* recordPtr){
	FieldList* field = recordPtr->fields;
	char* arr = (char*)malloc(sizeof(char)*30);
	char temp[20];
	while(field!=NULL){
		sprintf(temp,"%s%s",DataType[field->type],(field->next!=NULL)?" x ":"");
		strcat(arr,temp);
		field = field->next;
	}
	return arr;
}

void printSymbolTable(HashTable* htPtr){
    int i;
    Entry* ent;
    VariableNode* var;
    FunList* function = NULL;
    functions = NULL;
    FunVar* varList = NULL;
	for(i=0;i<htPtr->size;i++){
		ent = &(htPtr->table[i]);
		while(ent!=NULL){
			var = (VariableNode*)ent->value;
			if(var!=NULL){
				//printf("VariableNode=%s\n",var->varTok->lexemeName);
				if(var->funTok==NULL){
					var->funTok = (Token*)malloc(sizeof(Token));
					strcpy(var->funTok->lexemeName,"global");
				}
				if(functions==NULL){
					functions = createFunList(var->funTok,var);
				}
				else{
					function = functions;
					while(function!=NULL){
						//printf("%p %p %p\n",function,var,function->funTok);
						if(strcmp(function->funTok->lexemeName, var->funTok->lexemeName)==0){
							varList = function->varList;
							while(varList->next != NULL){
								varList = varList->next;
							}
							varList->next = createFunVar(var);
							break;
						}
						function = function->next;
					}
					if(function==NULL){
						function = functions;
						while(function->next!=NULL){
							function = function->next;
						}
						function->next = createFunList(var->funTok, var);
					}
				}
			}
			ent = ent->next;
		}
	}
	function = functions;
	while(function!=NULL){
		varList = function->varList;
		while(varList!= NULL){
			int isGlobal = varList->varNode->isGlobal;
			if(!isGlobal){
			printf("%-30s %-30s %-30s \t%d\n",
										varList->varNode->varTok->lexemeName,
										(varList->varNode->type<2)?DataType[varList->varNode->type]:printType(varList->varNode->recordPtr),
										(isGlobal==0)?varList->varNode->funTok->lexemeName:"global",
										varList->varNode->offset
										);
		    }
			else{
			printf("%-30s %-30s %-30s %-30s\n",
										varList->varNode->varTok->lexemeName,
										(varList->varNode->type<2)?DataType[varList->varNode->type]:printType(varList->varNode->recordPtr),
										(isGlobal==0)?varList->varNode->funTok->lexemeName:"global",
										"-----"
										);				
			}
			varList = varList->next;
		}
		function = function->next;
	}
}

void printHash4(HashTable* htPtr){
	printf("-------Printing the hash table------ size = %d %d\n",htPtr->size,htPtr->elem);
    int i;
	for(i=0;i<htPtr->size;i++){
		Entry* ent = &(htPtr->table[i]);
		while(ent!=NULL){
			if(ent->value!=NULL){
				printf("key = %d function = %s width=%d\n",
											ent->key,
											((FunctionNode*)ent->value)->funTok->lexemeName,
											((FunctionNode*)ent->value)->width
											);
				InputPar* head = ((FunctionNode*)ent->value)->inputPar;
				printf("Input Parameters\n");
				while(head!=NULL){
					printf("\t %s\n",head->token->lexemeName);
					head = head->next;
				}
				OutputPar* head1 = ((FunctionNode*)ent->value)->outputPar;
				printf("Output Parameters\n");
				while(head1!=NULL){
					printf("\t %s\n",head1->token->lexemeName);
					head1 = head1->next;
				}

			}
			ent = ent->next;
		}
	}
}

int main(int argc,char** argv){
	if(argc<2){
    	printf("Fatal Error:No source file passed as argument!!\n");
    	printf("\tUse command \"./toycompiler <path to source file> <path to output file>\"\n");
    	return 0;		
	}
	if(argc<3){
    	printf("Fatal Error:No output file passed as argument!!\n");
    	printf("\tUse command \"./toycompiler <path to source file> <path to output file>\"\n");
    	return 0;		
	}
	int choice;
	printInitMessage();	
	ASTNode* ast;
	char temp[100];
	ParseNode* parseNode;
	char command[100];
	while(1){
		scanf("%d",&choice);		
		switch(choice){
			case 10:  printWithoutComments(argv[1]);
					  printInitMessage();
					  break;
			case 1:   lexer(argv[1]);
					  printInitMessage();
					  break;
			case 2:   parser(argv[1],"stdout",1);
					  printInitMessage();
					  break;
			case 3:	  PRINT_AST = 1;
					  ShowErrors = 0;
					  parseNode = parser(argv[1],"stdout",0);
					  if(!HasErrors){
					  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }
					  if(!HasErrors) // If no errors are generated then compilation is successful. See error.h
    						printf("Compiled Successfully: Input source code is syntactically and semantically correct!!\n");

					  printInitMessage();
					  break;
			case 4:   PRINT_AST = 0;
					  parseNode = parser(argv[1],"stdout",0);
					  ShowErrors = 0;
					  if(!HasErrors){
					  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }
					  printf("Parse tree  Number of nodes = %d    Allocated Memory =  %d Bytes\n",
													PARSER_SIZE/(int)(sizeof(ParseNode)),PARSER_SIZE);
					  printf("AST  Number of nodes = %d    Allocated Memory =  %d Bytes\n",
													AST_SIZE/(int)(sizeof(ASTNode)),AST_SIZE);
					  printf("Compression percentage = %f\n",(1.0*(PARSER_SIZE-AST_SIZE)/PARSER_SIZE)*100.0);
					  printInitMessage();
					  break;
			case 5:   PRINT_AST = 0;
					  ShowErrors = 0;
					  parseNode = parser(argv[1],"stdout",0);
					  if(!HasErrors){
					  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }
					 printf("%-30s %-30s %-30s %-30s\n","Lexeme(identifier)","type","scope(name of the function/global)","offset");
		    		 printf("%-30s %-30s %-30s %-30s\n","------------------","-----","---------------------------------","------");
		    		 printSymbolTable(SYMBOL_TABLE.hashTable);
		    		 //printHash4(FUNCTION_TABLE.hashTable);
   				     printInitMessage();
		    		 break;
		    case 6: 
  					  //printHash3(SYMBOL_TABLE.hashTable);
		    		  ShowErrors = 1;
		    		  parseNode = parser(argv[1],"stdout",0);
		    		  if(!HasErrors){
		    		  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }

					  if(!HasErrors) // If no errors are generated then compilation is successful. See error.h
    						printf("Compiled Successfully: Input source code is syntactically and semantically correct!!\n");
			          printInitMessage();
			          break;			
			case 7: ShowErrors = 1;
					parseNode = parser(argv[1],"stdout",0);
					  if(!HasErrors){
					  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }
					  if(!HasErrors){
					  	startGeneration(ast);
					    generateASM(argv[2]);
					  }
					  if(!HasErrors) // If no errors are generated then compilation is successful. See error.h
    						printf("Compiled Successfully: Input source code is syntactically and semantically correct!!\n");
			          printInitMessage();
			          break;
			case 8: ShowErrors = 1;
					parseNode = parser(argv[1],"stdout",0);
					strcpy(temp,argv[2]);
					temp[strlen(temp)-4] = '\0';
			        sprintf(command,"nasm -felf64 %s && gcc %s.o && ./a.out",argv[2],temp);
					  if(!HasErrors){
					  	ast = createAST(parseNode,NULL);
					  	check(ast);
					  }
					  if(!HasErrors){
					  	startGeneration(ast);
					    generateASM(argv[2]);
					  }

					  if(!HasErrors) // If no errors are generated then compilation is successful. See error.h
    						printf("Compiled Successfully: Input source code is syntactically and semantically correct!!\n");
					  if(!HasErrors){
					  		 printf("Program is running\n");
					  		 system(command);
					  		 printf("Program successfully exited\n");
					  		 return 0;
					  }
			          printInitMessage();						
			case 0: return 0;
			default: return 0;
		}
	}
	return 0;
}
